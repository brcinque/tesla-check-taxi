#!/usr/bin/env python3
"""
Tesla Robotaxi Monitor - Archive Script
Archives old reports and creates backups of historical data
"""

import os
import shutil
import json
from datetime import datetime
from pathlib import Path

# Get script directory
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
OUTPUT_DIR = os.path.join(SCRIPT_DIR, 'output')
ARCHIVE_DIR = os.path.join(SCRIPT_DIR, 'archive')

def archive():
    """Archive old reports and create backups"""
    print("\n" + "="*80)
    print("TESLA MONITOR ARCHIVE SCRIPT")
    print("="*80 + "\n")
    
    # Create archive directory structure
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    archive_subdir = os.path.join(ARCHIVE_DIR, timestamp)
    
    try:
        os.makedirs(archive_subdir, exist_ok=True)
        print(f"üìÅ Created archive directory: {archive_subdir}\n")
    except Exception as e:
        print(f"‚ùå Error creating archive directory: {e}")
        return
    
    archived_items = []
    errors = []
    
    # 1. Archive output files
    print("üì¶ Archiving output files...")
    if os.path.exists(OUTPUT_DIR):
        output_files = [
            'tesla_robotaxi_dashboard.html',
            'tesla_robotaxi_dashboard.png',
            'tesla_robotaxi_report.txt',
            'tesla_robotaxi_history.json'
        ]
        
        for file in output_files:
            src = os.path.join(OUTPUT_DIR, file)
            if os.path.exists(src):
                try:
                    dst = os.path.join(archive_subdir, file)
                    shutil.copy2(src, dst)
                    file_size = os.path.getsize(src)
                    archived_items.append(f"‚úÖ Archived: {file} ({file_size:,} bytes)")
                except Exception as e:
                    errors.append(f"‚ùå Error archiving {file}: {e}")
    
    # 2. Create metadata file
    print("üìù Creating archive metadata...")
    try:
        metadata = {
            'timestamp': timestamp,
            'datetime': datetime.now().isoformat(),
            'archived_files': [item.split(': ')[1].split(' (')[0] for item in archived_items if '‚úÖ' in item],
            'archive_location': archive_subdir
        }
        
        # Load history data if available
        history_file = os.path.join(OUTPUT_DIR, 'tesla_robotaxi_history.json')
        if os.path.exists(history_file):
            with open(history_file, 'r') as f:
                history_data = json.load(f)
                if history_data.get('scores'):
                    metadata['latest_score'] = history_data['scores'][-1]
                    metadata['latest_date'] = history_data['dates'][-1]
                    metadata['total_runs'] = len(history_data['scores'])
        
        metadata_file = os.path.join(archive_subdir, 'archive_metadata.json')
        with open(metadata_file, 'w') as f:
            json.dump(metadata, f, indent=2)
        
        archived_items.append(f"‚úÖ Created: archive_metadata.json")
    except Exception as e:
        errors.append(f"‚ùå Error creating metadata: {e}")
    
    # 3. Create README for archive
    print("üìÑ Creating archive README...")
    try:
        readme_content = f"""# Tesla Robotaxi Monitor - Archive

**Archive Created**: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
**Archive ID**: {timestamp}

## Archived Files

"""
        for item in archived_items:
            if 'Archived:' in item:
                readme_content += f"- {item.split('Archived: ')[1]}\n"
        
        readme_content += f"""
## Archive Location

```
{archive_subdir}
```

## How to Use This Archive

1. **View HTML Dashboard**: Open `tesla_robotaxi_dashboard.html` in any browser
2. **View Report**: Open `tesla_robotaxi_report.txt` in any text editor
3. **View Chart**: Open `tesla_robotaxi_dashboard.png` with any image viewer
4. **Restore Data**: Copy `tesla_robotaxi_history.json` back to output directory

## Metadata

See `archive_metadata.json` for detailed information about this archive.

---
Generated by Tesla Robotaxi Monitor Archive Script
"""
        
        readme_file = os.path.join(archive_subdir, 'README.md')
        with open(readme_file, 'w') as f:
            f.write(readme_content)
        
        archived_items.append(f"‚úÖ Created: README.md")
    except Exception as e:
        errors.append(f"‚ùå Error creating README: {e}")
    
    # 4. List all archives
    print("\nüìö Existing archives:")
    if os.path.exists(ARCHIVE_DIR):
        archives = sorted([d for d in os.listdir(ARCHIVE_DIR) 
                          if os.path.isdir(os.path.join(ARCHIVE_DIR, d))], 
                         reverse=True)
        for i, archive in enumerate(archives[:10], 1):
            archive_path = os.path.join(ARCHIVE_DIR, archive)
            # Try to get metadata
            metadata_path = os.path.join(archive_path, 'archive_metadata.json')
            if os.path.exists(metadata_path):
                try:
                    with open(metadata_path, 'r') as f:
                        meta = json.load(f)
                        score = meta.get('latest_score', 'N/A')
                        print(f"   {i}. {archive} (Score: {score})")
                except:
                    print(f"   {i}. {archive}")
            else:
                print(f"   {i}. {archive}")
        
        if len(archives) > 10:
            print(f"   ... and {len(archives) - 10} more archives")
        
        total_size = sum(
            sum(os.path.getsize(os.path.join(dp, f)) for f in files)
            for archive in archives
            for dp, dn, files in os.walk(os.path.join(ARCHIVE_DIR, archive))
        )
        print(f"\n   Total archive size: {total_size:,} bytes ({total_size / 1024 / 1024:.2f} MB)")
    
    # Summary
    print("\n" + "="*80)
    print("ARCHIVE SUMMARY")
    print("="*80 + "\n")
    
    print(f"‚úÖ Archived {len([i for i in archived_items if '‚úÖ' in i])} items to:")
    print(f"   {archive_subdir}\n")
    
    for item in archived_items:
        print(f"   {item}")
    
    if errors:
        print(f"\n‚ö†Ô∏è  {len(errors)} errors encountered:")
        for error in errors:
            print(f"   {error}")
    
    print("\n" + "="*80)
    print(f"‚úÖ ARCHIVE COMPLETE - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("="*80 + "\n")
    
    return archive_subdir

if __name__ == "__main__":
    archive()

